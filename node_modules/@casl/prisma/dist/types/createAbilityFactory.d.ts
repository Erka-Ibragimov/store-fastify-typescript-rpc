import { AbilityOptions, AbilityOptionsOf, AbilityTuple, PureAbility, RawRuleFrom, RawRuleOf } from '@casl/ability';
export declare function createAbilityFactory<TModelName extends string, TPrismaQuery extends Record<string, any>>(): {
    <T extends PureAbility<any, TPrismaQuery>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> extends infer T_1 ? T_1 extends import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> ? T_1 extends import("@casl/ability/dist/types/types").AbilityTupleType<string, import("@casl/ability").SubjectType> ? import("@casl/ability").SubjectRawRule<T_1[0], T_1[1], T[typeof import("@casl/ability/dist/types/RuleIndex").ɵconditions]> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]>, string>> : never : never)[] | undefined, options?: AbilityOptionsOf<T> | undefined): T;
    <A extends AbilityTuple<string, import("@casl/ability").Subject> = [string, TModelName], C extends TPrismaQuery = TPrismaQuery>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<A> extends infer T_2 ? T_2 extends import("@casl/ability/dist/types/types").ToAbilityTypes<A> ? T_2 extends import("@casl/ability/dist/types/types").AbilityTupleType<string, import("@casl/ability").SubjectType> ? import("@casl/ability").SubjectRawRule<T_2[0], T_2[1], C> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<A>, string>> : never : never)[] | undefined, options?: AbilityOptions<A, C> | undefined): PureAbility<A, C>;
};
