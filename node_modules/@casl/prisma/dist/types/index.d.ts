import { AbilityOptions, AbilityTuple, PureAbility, RawRuleFrom } from '@casl/ability';
import { WhereInputPerModel, ModelName, PrismaQuery } from './prismaClientBoundTypes';
export type { PrismaQuery } from './prismaClientBoundTypes';
export type { Model, Subjects } from './runtime';
export { prismaQuery, ParsingQueryError } from './runtime';
declare const createPrismaAbility: {
    <T extends PureAbility<any, PrismaQuery<Record<string, any> & import("@casl/ability").ForcedSubject<string>>>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> extends infer T_1 ? T_1 extends import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> ? T_1 extends import("@casl/ability/dist/types/types").AbilityTupleType<string, import("@casl/ability").SubjectType> ? import("@casl/ability").SubjectRawRule<T_1[0], T_1[1], T[typeof import("@casl/ability/dist/types/RuleIndex").ɵconditions]> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]>, string>> : never : never)[] | undefined, options?: import("@casl/ability").AbilityOptionsOf<T> | undefined): T;
    <A extends AbilityTuple<string, import("@casl/ability").Subject> = [string, import("@prisma/client").Prisma.ModelName], C extends PrismaQuery<Record<string, any> & import("@casl/ability").ForcedSubject<string>> = PrismaQuery<Record<string, any> & import("@casl/ability").ForcedSubject<string>>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<A> extends infer T_2 ? T_2 extends import("@casl/ability/dist/types/types").ToAbilityTypes<A> ? T_2 extends import("@casl/ability/dist/types/types").AbilityTupleType<string, import("@casl/ability").SubjectType> ? import("@casl/ability").SubjectRawRule<T_2[0], T_2[1], C> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<A>, string>> : never : never)[] | undefined, options?: AbilityOptions<A, C> | undefined): PureAbility<A, C>;
};
declare const accessibleBy: (ability: PureAbility<any, PrismaQuery<Record<string, any> & import("@casl/ability").ForcedSubject<string>>>, action?: string) => WhereInputPerModel;
export { createPrismaAbility, accessibleBy, };
/**
 * Uses conditional type to support union distribution
 */
declare type ExtendedAbilityTuple<T extends AbilityTuple> = T extends AbilityTuple ? [T[0], 'all' | T[1]] : never;
/**
 * @deprecated use createPrismaAbility instead
 */
export declare class PrismaAbility<A extends AbilityTuple = [string, ModelName], C extends PrismaQuery = PrismaQuery> extends PureAbility<ExtendedAbilityTuple<A>, C> {
    constructor(rules?: RawRuleFrom<ExtendedAbilityTuple<A>, C>[], options?: AbilityOptions<ExtendedAbilityTuple<A>, C>);
}
