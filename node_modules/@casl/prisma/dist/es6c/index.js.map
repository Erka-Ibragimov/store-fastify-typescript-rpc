{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["import { AbilityOptions, AbilityTuple, fieldPatternMatcher, PureAbility, RawRuleFrom } from '@casl/ability';\nimport { createAbilityFactory, createAccessibleByFactory, prismaQuery } from './runtime';\nimport { WhereInputPerModel, ModelName, PrismaQuery } from './prismaClientBoundTypes';\n\nexport type { PrismaQuery } from './prismaClientBoundTypes';\nexport type { Model, Subjects } from './runtime';\nexport { prismaQuery, ParsingQueryError } from './runtime';\n\nconst createPrismaAbility = createAbilityFactory<ModelName, PrismaQuery>();\nconst accessibleBy = createAccessibleByFactory<WhereInputPerModel, PrismaQuery>();\n\nexport {\n  createPrismaAbility,\n  accessibleBy,\n};\n\n/**\n * Uses conditional type to support union distribution\n */\ntype ExtendedAbilityTuple<T extends AbilityTuple> = T extends AbilityTuple\n  ? [T[0], 'all' | T[1]]\n  : never;\n\n/**\n * @deprecated use createPrismaAbility instead\n */\nexport class PrismaAbility<\n  A extends AbilityTuple = [string, ModelName],\n  C extends PrismaQuery = PrismaQuery\n> extends PureAbility<ExtendedAbilityTuple<A>, C> {\n  constructor(\n    rules?: RawRuleFrom<ExtendedAbilityTuple<A>, C>[],\n    options?: AbilityOptions<ExtendedAbilityTuple<A>, C>\n  ) {\n    super(rules, {\n      conditionsMatcher: prismaQuery,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n"],"names":["createPrismaAbility","createAbilityFactory","accessibleBy","createAccessibleByFactory","PrismaAbility","PureAbility","constructor","rules","options","conditionsMatcher","prismaQuery","fieldMatcher","fieldPatternMatcher"],"mappings":"sIAQMA,EAAsBC,+BACtBC,EAAeC,8BAiBd,MAAMC,sBAGHC,cACRC,YACEC,EACAC,SAEMD,iBACJE,kBAAmBC,cACnBC,aAAcC,uBACXJ"}