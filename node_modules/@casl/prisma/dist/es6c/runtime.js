"use strict";Object.defineProperty(exports,"__esModule",{value:true});var t=require("@ucast/core");var e=require("@ucast/js");var r=require("@casl/ability/extra");var n=require("@casl/ability");class o extends Error{static invalidArgument(t,e,r){const n=`${typeof e}(${JSON.stringify(e,null,2)})`;return new this(`"${t}" expects to receive ${r} but instead got "${n}"`)}}const s=t=>t&&(t.constructor===Object||!t.constructor);const a={type:"field",validate(t,e){if(Array.isArray(e)||s(e))throw new o(`"${t.name}" does not supports comparison of arrays and objects`)}};const i={type:"field",parse(e,r,{hasOperators:n,field:a,parse:i}){if(s(r)&&!n(r)||Array.isArray(r))throw new o(`"${e.name}" does not supports comparison of arrays and objects`);if(!s(r))return new t.FieldCondition("notEquals",a,r);return new t.CompoundCondition("NOT",[i(r,{field:a})])}};const c={type:"field",validate(t,e){if(!Array.isArray(e))throw o.invalidArgument(t.name,e,"an array")}};const u={type:"field",validate(t,e){const r=typeof e;const n="string"===r||"number"===r&&Number.isFinite(e)||e instanceof Date;if(!n)throw o.invalidArgument(t.name,e,"comparable value")}};const l=new Set(["insensitive","default"]);const p={type:"field",validate(t,e){if(!l.has(e))throw o.invalidArgument(t.name,e,`one of ${Array.from(l).join(", ")}`)},parse:()=>t.NULL_CONDITION};const y={type:"field",validate(t,e){if("string"!==typeof e)throw o.invalidArgument(t.name,e,"string")},parse(e,r,{query:n,field:o}){const s="insensitive"===n.mode?`i${e.name}`:e.name;return new t.FieldCondition(s,o,r)}};const f={type:"compound",validate(t,e){if(!e||"object"!==typeof e)throw o.invalidArgument(t.name,e,"an array or object")},parse(e,r,{parse:n}){const o=Array.isArray(r)?r:[r];const s=o.map((t=>n(t)));return new t.CompoundCondition(e.name,s)}};const d={type:"field",validate(t,e){if("boolean"!==typeof e)throw o.invalidArgument(t.name,e,"a boolean")}};const h={type:"field"};const w={type:"field",validate(t,e){if(!Array.isArray(e))throw o.invalidArgument(t.name,e,"an array")}};const b={type:"field",parse(e,r,{field:n,parse:a}){if(!s(r))throw o.invalidArgument(e.name,r,"a query for nested relation");return new t.FieldCondition(e.name,n,a(r))}};const g=(e,r)=>{const n=r.parse;if(!n)return Object.assign({},r,{parse(r,n,o){return new t.CompoundCondition("NOT",[new t.FieldCondition(e,o.field,n)])}});return Object.assign({},r,{parse(r,o,s){const a=n(r,o,s);if(a.operator!==r.name)throw new Error(`Cannot invert "${e}" operator parser because it returns a complex Condition`);a.operator=e;return new t.CompoundCondition("NOT",[a])}})};const v={equals:a,not:i,in:c,notIn:g("in",c),lt:u,lte:u,gt:u,gte:u,mode:p,startsWith:y,endsWith:y,contains:y,isEmpty:d,has:h,hasSome:w,hasEvery:w,NOT:f,AND:f,OR:f,every:b,some:b,none:g("some",b),is:b,isNot:g("is",b)};class A extends t.ObjectQueryParser{constructor(){super(v,{defaultOperatorName:"equals"})}parse(e,r){if(r&&r.field)return t.buildAnd(this.parseFieldOperators(r.field,e));return super.parse(e)}}const m=(t,e,{get:r})=>r(e,t.field).startsWith(t.value);const O=(t,e,{get:r})=>r(e,t.field).toLowerCase().startsWith(t.value.toLowerCase());const j=(t,e,{get:r})=>r(e,t.field).endsWith(t.value);const N=(t,e,{get:r})=>r(e,t.field).toLowerCase().endsWith(t.value.toLowerCase());const $=(t,e,{get:r})=>r(e,t.field).includes(t.value);const q=(t,e,{get:r})=>r(e,t.field).toLowerCase().includes(t.value.toLowerCase());const x=(t,e,{get:r})=>{const n=r(e,t.field);const o=Array.isArray(n)&&0===n.length;return o===t.value};const E=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&n.includes(t.value)};const T=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.some((t=>n.includes(t)))};const W=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.every((t=>n.includes(t)))};const S=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.length>0&&o.every((e=>n(t.value,e)))};const _=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.some((e=>n(t.value,e)))};const D=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return o&&"object"===typeof o&&n(t.value,o)};const M=(t,e,{interpret:r})=>t.value.every((t=>!r(t,e)));function C(t){return t&&"object"===typeof t?t.valueOf():t}const F=(t,r)=>e.compare(C(t),C(r));const I=e.createJsInterpreter({equals:e.eq,notEquals:e.ne,in:e.within,lt:e.lt,lte:e.lte,gt:e.gt,gte:e.gte,startsWith:m,istartsWith:O,endsWith:j,iendsWith:N,contains:$,icontains:q,isEmpty:x,has:E,hasSome:T,hasEvery:W,and:e.and,or:e.or,AND:e.and,OR:e.or,NOT:M,every:S,some:_,is:D},{get:(t,e)=>t[e],compare:F});const R=new A;const J=t.createTranslatorFactory(R.parse,I);function P(t){return t.inverted?{NOT:t.conditions}:t.conditions}const k={get(t,e){const o=r.rulesToQuery(t.t,t.o,e,P);if(null===o){const r=n.ForbiddenError.from(t.t).setMessage(`It's not allowed to run "${t.o}" on "${e}"`);r.action=t.o;r.subjectType=r.subject=e;throw r}const s=Object.create(null);if(o.$or)s.OR=o.$or;if(o.$and)s.AND=o.$and;return s}};const z=()=>function t(e,r="read"){return new Proxy({t:e,o:r},k)};function createAbilityFactory(){function createAbility(t=[],e={}){return new n.PureAbility(t,Object.assign({},e,{conditionsMatcher:J,fieldMatcher:n.fieldPatternMatcher}))}return createAbility}exports.ParsingQueryError=o;exports.createAbilityFactory=createAbilityFactory;exports.createAccessibleByFactory=z;exports.prismaQuery=J;
//# sourceMappingURL=runtime.js.map
